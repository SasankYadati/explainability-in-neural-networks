# -*- coding: utf-8 -*-
"""Keras Model Lime

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ybj9-4N8KgEm-ojAEPvjFO3mhcrETSHC
"""

#Lime explanations using a KERAS Model

import keras

#Load the model

from keras.models import load_model

from google.colab import drive
drive.mount("/content/gdrive")

model = load_model('/content/gdrive/My Drive/8th Semester Project/my_model.h5')

#load dataset

import pickle

#x,y = pickle.load(open("/content/gdrive/My Drive/8th Semester Project/data.pickle","rb"))

!pip install lime

import lime
from lime import lime_image

def prediction_function(x):
  result = model.predict(x.reshape(-1,64,64,3).astype(np.float32))
  return result

def add_noise(image):
  row,col,ch = image.shape
  s_vs_p = 0.5
  amount = 0.01
  out = np.copy(image)
  # Salt mode
  num_salt = np.ceil(amount * image.size * s_vs_p)
  coords = [np.random.randint(0, i - 1, int(num_salt))
          for i in image.shape]
  out[coords] = 1

  # Pepper mode
  num_pepper = np.ceil(amount* image.size * (1. - s_vs_p))
  coords = [np.random.randint(0, i - 1, int(num_pepper))
          for i in image.shape]
  out[coords] = 0
  return out

from skimage.measure import structural_similarity as ssim
import cv2

def mse(imageA, imageB):
	# the 'Mean Squared Error' between the two images is the
	# sum of the squared difference between the two images;
	# NOTE: the two images must have the same dimension
	err = np.sum((imageA.astype("float") - imageB.astype("float")) ** 2)
	err /= float(imageA.shape[0] * imageA.shape[1])
	
	# return the MSE, the lower the error, the more "similar"
	# the two images are
	return err

def compare_images(imageA, imageB, title):
  # compute the mean squared error and structural similarity
  # index for the images
  m = mse(imageA, imageB)
  s = ssim(imageA, imageB,multichannel=True)

  # setup the figure
  fig = plt.figure(title)
  plt.suptitle("MSE: %.2f, SSIM: %.2f" % (m, s))

  # show first image
  ax = fig.add_subplot(1, 2, 1)
  plt.imshow(imageA, cmap = plt.cm.gray)
  plt.axis("off")

  # show the second image
  ax = fig.add_subplot(1, 2, 2)
  plt.imshow(imageB, cmap = plt.cm.gray)
  plt.axis("off")

  # show the images
  plt.show() 
  return m,s

from lime.wrappers.scikit_image import SegmentationAlgorithm

segmenter = SegmentationAlgorithm('quickshift', kernel_size=1, max_dist=200, ratio=0.2)

def return_explanation_image(image,y,filename):
  explanation = explainer.explain_instance(test_x[0],classifier_fn = prediction_function,top_labels=10, hide_color=0, num_samples=100, segmentation_fn=segmenter)
  output = y
  
  temp, mask = explanation.get_image_and_mask(output, positive_only=True, num_features=10, hide_rest=False, min_weight = 0.01)
  fig= plt.figure()
  (ax1) = fig.add_subplot(2,1,1)
  ax1.imshow(label2rgb(mask,temp, bg_label = 0), interpolation = 'nearest')
  ax1.set_title('Positive Regions for {}'.format(output))
  
  
  fig.savefig(filename)
  img = cv2.imread(filename)
  
  return img

#get train and test data

#some images have only one channel 
#so need to convert them into 3
#use sklearn for this

from skimage.color import gray2rgb

for i in range(len(x)):
  if(x[i].shape !=(64,64,3)):
    x[i] = gray2rgb(x[i])

import sklearn
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.15)

x_test = np.reshape(x_test,(-1,64,64,3))

number_of_samples = 200

stabilities = []

for i in range(number_of_samples):
  image = x_test[i]
  output = y_test[i]
  
  original_filename = "/content/gdrive/My Drive/8th Semester Project/test_1.jpeg"
  original_image_explanation = return_explanation_image(image,output,original_filename)
  
  noisy_input = add_noise(image)
  
  noisy_exp_filename = "/content/gdrive/My Drive/8th Semester Project/test_2.jpeg"
  noisy_image_explanation = return_explanation_image(noisy_input,output,noisy_exp_filename)
  
  m1,s1 = compare_images(image,noisy_input)
  m2,s2 = compare_images(original_image_explanation,noisy_image_explanation)
  
  stability = m2/m1
  
  stabilities.append(stability)

mean_stability = sum(stabilities)/len(stabilities)

print("Mean Stability of the Model is : ",mean_stability)